<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mathematics Prerequisite Map (Horizontal)</title>
  <style>
    :root{
      --bg:#f2f4f8; --card:#ffffff; --text:#2c3e50; --muted:#5b6b7a;
      --border:#d7dde6; --accent:#3498db; --line:#8aa3b8; --highlight:#ff7f0e;
      --req:#ff7f0e; --rec:#3498db;
    }
    html,body{height:100%}
    body{margin:0;font-family:Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{background:#2c3e50;color:#fff;padding:16px}
    header h1{margin:0;font-size:1.25em}
    header .sub{margin-top:6px;opacity:.9;font-size:.95em}

    .toolbar{display:flex;gap:10px;flex-wrap:wrap;padding:12px 16px;background:#fff;border-bottom:1px solid var(--border);align-items:center}
    .toolbar input,.toolbar select,.toolbar button{font-size:14px;padding:9px 10px;border:1px solid var(--border);border-radius:10px;background:#fff;color:var(--text)}
    .toolbar button{cursor:pointer}
    .toolbar .note{color:var(--muted);font-size:.92em}

    .viewport{position:relative;height:calc(100vh - 124px);overflow-x:auto;overflow-y:hidden;padding:16px;box-sizing:border-box;scroll-behavior:smooth;white-space:nowrap}
    .stage{position:relative;display:inline-flex;gap:16px;align-items:flex-start;padding-bottom:40px;min-height:100%;box-sizing:border-box}

    .level{width:380px;background:rgba(255,255,255,.6);border:1px solid var(--border);border-radius:14px;padding:12px;box-sizing:border-box}
    .level h2{margin:0 0 10px 0;font-size:1.05em;border-bottom:2px solid var(--accent);padding-bottom:8px}

    .node{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px;margin-bottom:10px;box-shadow:0 2px 6px rgba(0,0,0,.06);cursor:pointer;user-select:none}
    .node:hover{border-color:rgba(52,152,219,.8)}
    .node .title{font-weight:700;font-size:.95em;margin:0;line-height:1.25}
    .node .meta{margin-top:6px;font-size:.86em;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}
    .pill{border:1px solid var(--border);border-radius:999px;padding:2px 8px;background:#fbfcfe}
    .node.selected{border-color:var(--highlight);box-shadow:0 0 0 3px rgba(255,127,14,.18)}
    .node.dim{opacity:.25}
    .node.upstream{border-left:6px solid var(--accent)}
    .node.downstream{border-left:6px solid var(--highlight)}

    .panel{position:absolute;top:16px;right:16px;width:380px;max-height:calc(100vh - 160px);overflow:auto;background:#fff;border:1px solid var(--border);border-radius:14px;box-shadow:0 2px 8px rgba(0,0,0,.10);padding:12px}
    .panel h3{margin:0 0 10px 0;font-size:1.05em;border-bottom:2px solid var(--accent);padding-bottom:8px}
    .panel .line{font-size:.92em;color:var(--muted);margin:8px 0}
    .panel ul{margin:8px 0 0 18px;padding:0;font-size:.95em}
    .panel li{margin:4px 0}
    .panel a{color:var(--text);text-decoration:none}
    .panel a:hover{color:#2980b9;text-decoration:underline}

    svg#links{position:absolute;left:0;top:0;pointer-events:none}
  </style>
</head>

<body>
  <header>
    <h1>Mathematics Prerequisite Map (Horizontal)</h1>
    <div class="sub">Left is foundational. Right is advanced. Lines indicate prerequisite dependency. Required and recommended edges are drawn differently.</div>
  </header>

  <div class="toolbar">
    <input id="search" type="text" placeholder="Search topics" />
    <select id="focusSelect"></select>
    <button id="resetBtn" type="button">Reset view</button>
    <button id="redrawBtn" type="button">Redraw lines</button>
    <span class="note">Selecting a topic highlights prerequisites (upstream) and dependents (downstream).</span>
  </div>

  <div id="viewport" class="viewport">
    <svg id="links"></svg>
    <div id="stage" class="stage"></div>

    <div id="detailPanel" class="panel" style="display:none;">
      <h3 id="panelTitle">Topic</h3>
      <div id="panelMeta" class="line"></div>
      <div class="line"><strong>Direct prerequisites:</strong></div>
      <ul id="panelReq"></ul>
      <div class="line"><strong>All prerequisites (transitive):</strong></div>
      <ul id="panelReqAll"></ul>
      <div class="line"><strong>Direct dependents:</strong></div>
      <ul id="panelDep"></ul>
    </div>
  </div>

  <script>
    const LEVELS = ["KS2","KS3","GCSE","A-Level","BSc","MSc","Frontier"];

    let NODES = [];
    let EDGES = [];
    let byId = new Map();
    let edgesFrom = new Map();
    let edgesTo = new Map();

    const viewport = document.getElementById("viewport");
    const stage = document.getElementById("stage");
    const svg = document.getElementById("links");

    const searchEl = document.getElementById("search");
    const focusSelect = document.getElementById("focusSelect");
    const resetBtn = document.getElementById("resetBtn");
    const redrawBtn = document.getElementById("redrawBtn");

    const detailPanel = document.getElementById("detailPanel");
    const panelTitle = document.getElementById("panelTitle");
    const panelMeta = document.getElementById("panelMeta");
    const panelReq = document.getElementById("panelReq");
    const panelReqAll = document.getElementById("panelReqAll");
    const panelDep = document.getElementById("panelDep");

    let selectedId = null;
    let nodeEls = new Map();

    function escapeHtml(s){
      return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function indexGraph(){
      byId = new Map(NODES.map(n => [n.id, n]));
      edgesFrom = new Map();
      edgesTo = new Map();

      for (const e of EDGES){
        if (!edgesFrom.has(e.from)) edgesFrom.set(e.from, []);
        if (!edgesTo.has(e.to)) edgesTo.set(e.to, []);
        edgesFrom.get(e.from).push(e);
        edgesTo.get(e.to).push(e);
      }
    }

    function createLevelColumn(level){
      const col = document.createElement("div");
      col.className = "level";
      col.dataset.level = level;
      col.innerHTML = `<h2>${escapeHtml(level)}</h2>`;
      return col;
    }

    function renderColumns(){
      stage.innerHTML = "";
      nodeEls.clear();

      const columns = new Map();
      for (const level of LEVELS){
        const col = createLevelColumn(level);
        columns.set(level, col);
        stage.appendChild(col);
      }

      for (const node of NODES){
        const col = columns.get(node.level);
        if (!col) continue;

        const el = document.createElement("div");
        el.className = "node";
        el.id = `node_${node.id}`;
        el.dataset.id = node.id;

        const prereqCount = (edgesTo.get(node.id) || []).length;
        const depCount = (edgesFrom.get(node.id) || []).length;

        el.innerHTML = `
          <div class="title">${escapeHtml(node.title)}</div>
          <div class="meta">
            <span class="pill">Prereqs: ${prereqCount}</span>
            <span class="pill">Dependents: ${depCount}</span>
            <span class="pill">${escapeHtml(node.domain || "General")}</span>
          </div>
        `;
        el.addEventListener("click", () => select(node.id));
        col.appendChild(el);
        nodeEls.set(node.id, el);
      }
    }

    function buildFocusSelect(){
      const opts = [`<option value="">Focus topic (jump)</option>`].concat(
        NODES.slice().sort((a,b)=>a.title.localeCompare(b.title))
          .map(n => `<option value="${escapeHtml(n.id)}">${escapeHtml(n.title)}</option>`)
      );
      focusSelect.innerHTML = opts.join("");
      focusSelect.addEventListener("change", () => {
        const id = focusSelect.value;
        if (!id) return;
        select(id);
        jumpTo(id);
      });
    }

    function jumpTo(id){
      const el = nodeEls.get(id);
      if (!el) return;
      const vpRect = viewport.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      const currentScroll = viewport.scrollLeft;
      const elCenter = (elRect.left - vpRect.left) + (elRect.width / 2);
      const target = currentScroll + elCenter - (vpRect.width / 2);
      viewport.scrollLeft = Math.max(0, target);
    }

    function getAllPrereqs(startId){
      const seen = new Set();
      const stack = (edgesTo.get(startId) || []).map(e => e.from);
      while (stack.length){
        const id = stack.pop();
        if (seen.has(id)) continue;
        seen.add(id);
        for (const e of (edgesTo.get(id) || [])) stack.push(e.from);
      }
      return seen;
    }

    function getAllDependents(startId){
      const seen = new Set();
      const stack = (edgesFrom.get(startId) || []).map(e => e.to);
      while (stack.length){
        const id = stack.pop();
        if (seen.has(id)) continue;
        seen.add(id);
        for (const e of (edgesFrom.get(id) || [])) stack.push(e.to);
      }
      return seen;
    }

    function clearList(ul){
      while (ul.firstChild) ul.removeChild(ul.firstChild);
    }

    function addListItem(ul, id){
      const n = byId.get(id);
      const li = document.createElement("li");
      if (!n){ li.textContent = id; ul.appendChild(li); return; }
      const a = document.createElement("a");
      a.href = "#";
      a.textContent = n.title;
      a.addEventListener("click", (ev) => { ev.preventDefault(); select(n.id); jumpTo(n.id); });
      li.appendChild(a);
      ul.appendChild(li);
    }

    function renderPanel(id){
      const n = byId.get(id);
      if (!n) return;

      detailPanel.style.display = "block";
      panelTitle.textContent = n.title;

      const directReqEdges = (edgesTo.get(id) || []).slice();
      const directDepEdges = (edgesFrom.get(id) || []).slice();

      const directReq = directReqEdges.map(e => e.from).map(x => byId.get(x)).filter(Boolean);
      const directDep = directDepEdges.map(e => e.to).map(x => byId.get(x)).filter(Boolean);
      const allReq = [...getAllPrereqs(id)].map(x => byId.get(x)).filter(Boolean);

      panelMeta.textContent = `Level: ${n.level} | Domain: ${n.domain || "General"} | Direct prerequisites: ${directReq.length} | Direct dependents: ${directDep.length}`;

      clearList(panelReq);
      clearList(panelReqAll);
      clearList(panelDep);

      directReq.sort((a,b)=>a.title.localeCompare(b.title)).forEach(x => addListItem(panelReq, x.id));
      allReq.sort((a,b)=>a.title.localeCompare(b.title)).forEach(x => addListItem(panelReqAll, x.id));
      directDep.sort((a,b)=>a.title.localeCompare(b.title)).forEach(x => addListItem(panelDep, x.id));
    }

    function applyHighlight(id){
      for (const el of nodeEls.values()){
        el.classList.remove("selected","dim","upstream","downstream");
      }
      if (!id){
        redrawLines(null);
        detailPanel.style.display = "none";
        return;
      }

      const prereqs = getAllPrereqs(id);
      const deps = getAllDependents(id);

      for (const [nid, el] of nodeEls.entries()){
        const isSelected = nid === id;
        const isUp = prereqs.has(nid);
        const isDown = deps.has(nid);

        if (isSelected) el.classList.add("selected");
        if (isUp) el.classList.add("upstream");
        if (isDown) el.classList.add("downstream");

        if (!(isSelected || isUp || isDown)) el.classList.add("dim");
      }
      redrawLines({ focusId:id, prereqs, deps });
    }

    function select(id){
      selectedId = id;
      renderPanel(id);
      applyHighlight(id);
    }

    function filterNodes(query){
      const q = query.trim().toLowerCase();
      if (!q){
        for (const el of nodeEls.values()) el.style.display = "";
        redrawLines(selectedId ? { focusId:selectedId, prereqs:getAllPrereqs(selectedId), deps:getAllDependents(selectedId) } : null);
        return;
      }

      const visible = new Set();
      for (const n of NODES){
        const hit = (n.title || "").toLowerCase().includes(q) || (n.domain || "").toLowerCase().includes(q);
        const el = nodeEls.get(n.id);
        if (!el) continue;
        el.style.display = hit ? "" : "none";
        if (hit) visible.add(n.id);
      }
      redrawLines(selectedId ? { focusId:selectedId, prereqs:getAllPrereqs(selectedId), deps:getAllDependents(selectedId), visible } : { visible });
    }

    function svgClear(){
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    }

    function getElBoxInViewportSpace(el){
      const vpRect = viewport.getBoundingClientRect();
      const r = el.getBoundingClientRect();
      const x = (r.left - vpRect.left) + viewport.scrollLeft;
      const y = (r.top - vpRect.top) + viewport.scrollTop;
      return { x, y, w:r.width, h:r.height };
    }

    function redrawLines(context){
      const contentWidth = stage.scrollWidth + 32;
      const contentHeight = Math.max(stage.scrollHeight + 32, viewport.clientHeight);

      svg.setAttribute("width", String(contentWidth));
      svg.setAttribute("height", String(contentHeight));
      svg.style.width = contentWidth + "px";
      svg.style.height = contentHeight + "px";

      svgClear();

      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute("id", "arrow");
      marker.setAttribute("viewBox", "0 0 10 10");
      marker.setAttribute("refX", "9");
      marker.setAttribute("refY", "5");
      marker.setAttribute("markerWidth", "7");
      marker.setAttribute("markerHeight", "7");
      marker.setAttribute("orient", "auto-start-reverse");

      const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      arrowPath.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
      arrowPath.setAttribute("fill", "var(--line)");
      marker.appendChild(arrowPath);
      defs.appendChild(marker);
      svg.appendChild(defs);

      const visibleSet = context?.visible instanceof Set ? context.visible : null;

      for (const e of EDGES){
        const fromEl = nodeEls.get(e.from);
        const toEl = nodeEls.get(e.to);
        if (!fromEl || !toEl) continue;
        if (fromEl.style.display === "none" || toEl.style.display === "none") continue;
        if (visibleSet && (!visibleSet.has(e.from) || !visibleSet.has(e.to))) continue;

        const a = getElBoxInViewportSpace(fromEl);
        const b = getElBoxInViewportSpace(toEl);

        const x1 = a.x + a.w;
        const y1 = a.y + (a.h / 2);
        const x2 = b.x;
        const y2 = b.y + (b.h / 2);

        const dx = Math.max(60, (x2 - x1) * 0.45);
        const c1x = x1 + dx, c1y = y1;
        const c2x = x2 - dx, c2y = y2;

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`);
        path.setAttribute("fill", "none");

        let width = 1.4;
        let opacity = 0.65;
        let dash = "";
        let stroke = "var(--line)";

        if (e.type === "required"){
          stroke = "var(--req)";
          width = 2.2;
          opacity = 0.85;
        } else if (e.type === "recommended"){
          stroke = "var(--rec)";
          width = 1.8;
          dash = "6 4";
          opacity = 0.65;
        }

        if (context?.focusId){
          const onFocusBand =
            (e.to === context.focusId) ||
            (context.prereqs?.has(e.to) && (context.prereqs?.has(e.from) || e.from === context.focusId)) ||
            (context.deps?.has(e.from) && (context.deps?.has(e.to) || e.to === context.focusId));

          if (!onFocusBand) opacity = 0.12;
          else opacity = Math.max(opacity, 0.92);
        }

        path.setAttribute("stroke", stroke);
        path.setAttribute("stroke-width", String(width));
        path.setAttribute("opacity", String(opacity));
        if (dash) path.setAttribute("stroke-dasharray", dash);
        path.setAttribute("marker-end", "url(#arrow)");

        svg.appendChild(path);
      }
    }

    function resetView(){
      selectedId = null;
      focusSelect.value = "";
      searchEl.value = "";
      for (const el of nodeEls.values()) el.style.display = "";
      applyHighlight(null);
      redrawLines(null);
    }

    async function loadJson(){
      const res = await fetch("./math-topics.json", { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load math-topics.json");
      const data = await res.json();
      NODES = data.nodes || [];
      EDGES = data.edges || [];
      indexGraph();
    }

    async function init(){
      await loadJson();
      renderColumns();
      buildFocusSelect();
      redrawLines(null);

      viewport.addEventListener("scroll", () => {
        const ctx = selectedId ? { focusId:selectedId, prereqs:getAllPrereqs(selectedId), deps:getAllDependents(selectedId) } : null;
        redrawLines(ctx);
      });

      window.addEventListener("resize", () => {
        const ctx = selectedId ? { focusId:selectedId, prereqs:getAllPrereqs(selectedId), deps:getAllDependents(selectedId) } : null;
        redrawLines(ctx);
      });

      searchEl.addEventListener("input", () => filterNodes(searchEl.value));
      resetBtn.addEventListener("click", resetView);
      redrawBtn.addEventListener("click", () => {
        const ctx = selectedId ? { focusId:selectedId, prereqs:getAllPrereqs(selectedId), deps:getAllDependents(selectedId) } : null;
        redrawLines(ctx);
      });

      // Default focus: Real Analysis I (useful hub) if present
      if (byId.has("bsc_real_analysis")) {
        select("bsc_real_analysis");
        jumpTo("bsc_real_analysis");
      }
    }

    init().catch(err => {
      console.error(err);
      alert("Load failed. Ensure math-prereq-map.html and math-topics.json are in the same folder and served from a local web server.");
    });
  </script>
</body>
</html>
